<link rel='import' href='../bower_components/polymer/polymer.html'>

<link rel='import' href='../bower_components/core-list/core-list.html'>
<link rel='import' href='../bower_components/core-field/core-field.html'>
<link rel='import' href='../bower_components/paper-input/paper-input.html'>
<link rel='import' href='../bower_components/paper-icon-button/paper-icon-button.html'>
<link rel='import' href='../bower_components/paper-toast/paper-toast.html'>
<link rel='import' href='../bower_components/paper-button/paper-button.html'>

<polymer-element name='switchyd-servers'>
    <template>
        <!-- server list -->
        <core-list data='{{datas}}'>
            <template>
                <core-field>
                    <paper-input error='example: PROXY 127.0.0.1:10086 or SOCKS5 127.0.0.1:10087' index={{index}} on-change='{{change}}' value='{{model.type}} {{model.ip}}:{{model.port}}'></paper-input>
                    <paper-icon-button index='{{index}}' on-tap='{{add}}' icon="add"></paper-icon-button>
                    <paper-icon-button index='{{index}}' on-tap='{{remove}}' icon="remove"></paper-icon-button>
                <core-field>
            </template>
        </core-list>
        
        <!-- notify center-->
        <paper-toast id='toast' text='Proxy Server Applied'></paper-toast>
    </template>

    <script>
        Polymer('switchyd-servers',{
            datas:[],
            
            ok : false,

            ready:function(){
                var self = this;
                chrome.runtime.getBackgroundPage(function(app){
                    // need to replicate it.
                    // direct assign may lead to some bugs?
                    // chrome seems to seperate option page and background page in diffrenet sandbox,so observer on a `share` object would `actually` replicate.
                    // two identical observe function will trigger with different context
                    self.datas = app.switchyd.config.servers.map(function(unit){
                        return unit;    
                    });

                    self.ok = true;
                });
            },
            
            datasChanged:function(old,now){
                this.sync();
            },

            add:function(event,detail,sender,target){
                var index = sender.attributes.index.value;
                this.datas.splice(index,0,this.datas[index]);
                
                // modifyed
                this.sync();
            },

            remove:function(event,detail,sender,target){
                var index = sender.attributes.index.value;
                
                if(this.datas.length > 1){
                    this.datas.splice(index,1);
                    this.sync();
                }
            },
            
            parse:function(raw){
                // trim
                raw = raw.trim()
                
                // find indicator 
                var space = raw.indexOf(' ');
                if( space == -1 ){
                    return null;
                }
                
                // parse type
                var type = raw.substr(0,space);
                
                // server 
                var server = raw.substr(space).trim().split(':').map(function(item){
                    return item.trim();
                });
                
                if(server.length != 2){
                    return null;
                }
                
                return {
                    type:type.toUpperCase(),
                    ip:server[0],
                    port:server[1],
                };
            },

            change:function(event,detail,sender,target){
                // try parser new config
                var parsed = this.parse(sender.inputValue);

                // parse ok
                if( parsed ){
                    // figure out which changed
                    var index = sender.attributes.index.value;

                    sender.invalid = false;
                    this.datas.splice(index,1,parsed);
                    
                    // rebuild input value
                    // since parse change type to upper case in which the orign type might also in upper case meanwhile the input value typed would be in lower case.
                    // so correct it here
                    sender.inputValue = parsed.type + ' ' + parsed.ip + ':' + parsed.port; 
                    
                    this.sync();
                    return;
                }
                
                // or it failed
                sender.invalid = true;
            },
            
            sync:function(){
                var self = this; 
                chrome.runtime.getBackgroundPage(function(app){
                    var switchyd = app.switchyd; 
                    switchyd.config.servers = self.datas.map(function(unit){
                        return unit;        
                    });

                    // persist
                    switchyd.sync.save();

                    // apply change
                    switchyd.async.enqueue();
                    
                    if(ok){
                        self.$.toast.show();
                    }
                });
            }
        });
    </script>
</polymer-element>
